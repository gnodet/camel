#set( $newline="
")
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ${packageName};

#set( $imports = ${main.newTreeSet()} )
#if( $data.name == 'choice' )
#set( $b = ${imports.add('org.apache.camel.Predicate')} )
#set( $b = ${imports.add('org.apache.camel.builder.ExpressionClause')} )
#set( $b = ${imports.add('org.apache.camel.model.language.ExpressionDefinition')} )
#set( $b = ${imports.add('org.apache.camel.spi.AsPredicate')} )
#elseif ($data.name == 'loadBalance' )
#set( $b = ${imports.add('java.util.Arrays')} )
#set( $b = ${imports.add('java.util.stream.Collectors')} )
#set( $b = ${imports.add('org.apache.camel.Expression')} )
#set( $b = ${imports.add('org.apache.camel.model.language.ExpressionDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.FailoverLoadBalancerDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.RandomLoadBalancerDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.RoundRobinLoadBalancerDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.StickyLoadBalancerDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.TopicLoadBalancerDefinition')} )
#set( $b = ${imports.add('org.apache.camel.model.loadbalancer.WeightedLoadBalancerDefinition')} )
#elseif( $data.name == 'doTry' )
#set( $b = ${imports.add('java.util.Arrays')} )
#end
#set( $b = ${imports.addAll(${main.getImports(${data}, ${packageName})})} )
#foreach( $imp in ${imports} )
import ${imp};
#end

/**
 * ${data.description}
 *
 * Generated by camel meta-model tooling
 */
@SuppressWarnings({"unused", "WeakerAccess"})
@javax.annotation.Generated("org.apache.camel.metamodel")
#set( $hasOutput = false )
#set( $hasExpression = false )
#foreach( $prop in ${data.properties} )
    #if( ${prop.name} == "outputs" )
        #set( $hasOutput = true )
    #elseif( ${prop.name} == "expression" )
        #set( $hasExpression = true )
    #end
#end
#if( $hasOutput && $hasExpression )
    #set( $parent = "OutputExpressionNode" )
#elseif( $hasOutput )
    #set( $parent = "OutputDefinition" )
#elseif( $hasExpression )
    #set( $parent = "ExpressionNode" )
#else
    #set( $parent = "NoOutputDefinition" )
#end
#set( $param = "" )
#set( $paramst = "" )
#if( ${data.param} )
    #set( $param = "${data.param}, " )
    #set( $paramst = ${main.substringBefore(${data.param}," ")} + ", " )
#end
public class ${name}<${param}Type extends ProcessorDefinition<Type>> extends ${parent}<${name}<${paramst}Type>> {

#foreach( $en in ${main.getEnums(${data}).entrySet()} )
    public enum ${en.key} {
    #set( $cplx = false )
    #foreach( $v in ${en.value} )
        #if( ${v.contains(":")} )
            #set( $cplx = true )
        #end
    #end
    #if( $cplx )
        #foreach( $v in ${en.value} )
        ${v.substring(0, ${v.indexOf(":")})}("${v.substring(${v.indexOf(":")}+1)}")#if( $foreach.hasNext ),#{else};#end
        #end

        private String value;
        ${en.key}(String value) {
            this.value = value;
        }
        public String toString() {
            return value;
        }
    #else
        #foreach( $v in ${en.value} )
        $v#if( $foreach.hasNext ),#end
        #end
    #end
    }
#end

    public ${name}() {
    }

    @Override
    public String getShortName() {
        return "${data.name}";
    }

#if( $data.name == 'intercept' || $data.name == 'interceptFrom' || $data.name == 'interceptSendToEndpoint' )
    public void afterPropertiesSet() {
        // TODO
    }

#elseif( $data.name == 'route' )
    private boolean isRest;
    public boolean isRest() {
        return isRest;
    }
    public RouteDefinition<Type> rest() {
        this.isRest = true;
        return this;
    }

    public boolean isPrepared() {
        return true; // TODO
    }

    public void markPrepared() {
    }

    /**
     * Declare the expected data type of the input message with content validation enabled.
     * If the actual message type is different at runtime, camel look for a required
     * {@link Transformer} and apply if exists, and then applies {@link Validator} as well.
     * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'
     * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.
     *
     * @see org.apache.camel.spi.Transformer
     * @see org.apache.camel.spi.Validator
     *
     * @param urn input type URN
     * @return the builder
     */
    public RouteDefinition<Type> inputTypeWithValidate(String urn) {
        return inputType(new InputTypeDefinition().urn(urn).validate(true));
    }

    /**
     * Declare the expected data type of the input message by Java class.
     * If the actual message type is different at runtime, camel look for a required
     * {@link Transformer} and apply if exists.
     *
     * @see org.apache.camel.spi.Transformer
     *
     * @param clazz Class object of the input type
     * @return the builder
     */
    public RouteDefinition<Type> inputType(Class clazz) {
        return inputType("java:" + clazz.getName());
    }

    /**
     * Declare the expected data type of the input message by Java class with content validation enabled.
     * If the actual message type is different at runtime, camel look for a required
     * {@link Transformer} and apply if exists, and then applies {@link Validator} as well.
     *
     * @see org.apache.camel.spi.Transformer
     * @see org.apache.camel.spi.Validator
     *
     * @param clazz Class object of the input type
     * @return the builder
     */
    public RouteDefinition<Type> inputTypeWithValidate(Class clazz) {
        return inputTypeWithValidate("java:" + clazz.getName());
    }

    /**
     * Declare the expected data type of the output message with content validation enabled.
     * If the actual message type is different at runtime, Camel look for a required
     * {@link Transformer} and apply if exists, and then applies {@link Validator} as well.
     * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'
     * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.
     *
     * @see org.apache.camel.spi.Transformer
     * @see org.apache.camel.spi.Validator
     *
     * @param urn output type URN
     * @return the builder
     */
    public RouteDefinition<Type> outputTypeWithValidate(String urn) {
        return outputType(new OutputTypeDefinition().urn(urn).validate(true));
    }

    /**
     * Declare the expected data type of the output message by Java class.
     * If the actual message type is different at runtime, camel look for a required
     * {@link Transformer} and apply if exists.
     *
     * @see org.apache.camel.spi.Transformer
     *
     * @param clazz Class object of the output type
     * @return the builder
     */
    public RouteDefinition<Type> outputType(Class clazz) {
        return outputType(new OutputTypeDefinition().urn("java:" + clazz.getName()).validate(false));
    }

    /**
     * Declare the expected data type of the ouput message by Java class with content validation enabled.
     * If the actual message type is different at runtime, camel look for a required
     * {@link Transformer} and apply if exists, and then applies {@link Validator} as well.
     *
     * @see org.apache.camel.spi.Transformer
     * @see org.apache.camel.spi.Validator
     * @param clazz Class object of the output type
     * @return the builder
     */
    public RouteDefinition<Type> outputTypeWithValidate(Class clazz) {
        return outputTypeWithValidate("java:" + clazz.getName());
    }

#elseif( $data.name == 'choice' )
    /**
     * Sets the predicate for the when node
     *
     * @param predicate the predicate
     * @return the builder
     */
    public ChoiceDefinition<?> when(Predicate predicate) {
        WhenDefinition when = new WhenDefinition();
        when.expression(new ExpressionDefinition(predicate));
        addWhenClause(when);
        return this;
    }

    /**
     * Creates an expression for the when node
     *
     * @return expression to be used as builder to configure the when node
     */
    @AsPredicate
    public ExpressionClause<ChoiceDefinition<Type>> when() {
        ExpressionClause<ChoiceDefinition<Type>> clause = new ExpressionClause<ChoiceDefinition<Type>>(this);
        WhenDefinition when = new WhenDefinition();
        when.expression(new ExpressionDefinition((Predicate) clause));
        addWhenClause(when);
        return clause;
    }

    /**
     * Sets the otherwise node
     *
     * @return the builder
     */
    public ChoiceDefinition<Type> otherwise() {
        return otherwise(new OtherwiseDefinition());
    }

#elseif( $data.name == 'doTry' )
    /**
     * Handles the given exception
     *
     * @param exceptionType  the exception
     * @return the try builder
     */
    @SuppressWarnings("unchecked")
    public TryDefinition<Type> doCatch(Class<? extends Throwable> exceptionType) {
        // this method is introduced to avoid compiler warnings about the
        // generic Class arrays in the case we've got only one single Class
        // to build a TryDefinition for
        return doCatch(new Class[] {exceptionType});
    }

    /**
     * Handles the given exception(s)
     *
     * @param exceptionType  the exception(s)
     * @return the try builder
     */
    public TryDefinition<Type> doCatch(Class<? extends Throwable>... exceptionType) {
        popBlock();
        List<Class<? extends Throwable>> list = Arrays.asList(exceptionType);
        CatchDefinition answer = new CatchDefinition().exceptions(list);
        addOutput(answer);
        pushBlock(answer);
        return this;
    }

    /**
     * The finally block for a given handle
     *
     * @return  the try builder
     */
    public TryDefinition<Type> doFinally() {
        popBlock();
        FinallyDefinition answer = new FinallyDefinition();
        addOutput(answer);
        pushBlock(answer);
        return this;
    }

#elseif( $data.name == 'loadBalance' )
    /**
     * Uses fail over load balancer
     * <p/>
     * Will not round robin and inherit the error handler.
     *
     * @return the builder
     */
    public LoadBalanceDefinition<Type> failover() {
        return failover(-1, true, false);
    }

    /**
     * Uses fail over load balancer
     * <p/>
     * Will not round robin and inherit the error handler.
     *
     * @param exceptions exception classes which we want to failover if one of them was thrown
     * @return the builder
     */
    public LoadBalanceDefinition<Type> failover(Class<?>... exceptions) {
        return failover(-1, true, false, exceptions);
    }

    /**
     * Uses fail over load balancer
     *
     * @param maximumFailoverAttempts  maximum number of failover attempts before exhausting.
     *                                 Use -1 to newer exhaust when round robin is also enabled.
     *                                 If round robin is disabled then it will exhaust when there are no more endpoints to failover
     * @param inheritErrorHandler      whether or not to inherit error handler.
     *                                 If <tt>false</tt> then it will failover immediately in case of an exception
     * @param roundRobin               whether or not to use round robin (which keeps state)
     * @param exceptions               exception classes which we want to failover if one of them was thrown
     * @return the builder
     */
    public LoadBalanceDefinition<Type> failover(int maximumFailoverAttempts, boolean inheritErrorHandler, boolean roundRobin, Class<?>... exceptions) {
        return failover(maximumFailoverAttempts, inheritErrorHandler, roundRobin, false, exceptions);
    }

    /**
     * Uses fail over load balancer
     *
     * @param maximumFailoverAttempts  maximum number of failover attempts before exhausting.
     *                                 Use -1 to newer exhaust when round robin is also enabled.
     *                                 If round robin is disabled then it will exhaust when there are no more endpoints to failover
     * @param inheritErrorHandler      whether or not to inherit error handler.
     *                                 If <tt>false</tt> then it will failover immediately in case of an exception
     * @param roundRobin               whether or not to use round robin (which keeps state)
     * @param sticky                   whether or not to use sticky (which keeps state)
     * @param exceptions               exception classes which we want to failover if one of them was thrown
     * @return the builder
     */
    public LoadBalanceDefinition<Type> failover(int maximumFailoverAttempts, boolean inheritErrorHandler, boolean roundRobin, boolean sticky, Class<?>... exceptions) {
        FailoverLoadBalancerDefinition def = new FailoverLoadBalancerDefinition();
        def.exceptions(Arrays.asList(exceptions).stream().map(Class::getName).collect(Collectors.toList()));
        def.setMaximumFailoverAttempts(maximumFailoverAttempts);
        def.setRoundRobin(roundRobin);
        def.setSticky(sticky);
        setLoadBalancerType(def);
        this.setInheritErrorHandler(inheritErrorHandler);
        return this;
    }

    /**
     * Uses weighted load balancer
     *
     * @param roundRobin                   used to set the processor selection algorithm.
     * @param distributionRatio            String of weighted ratios for distribution of messages.
     * @return the builder
     */
    public LoadBalanceDefinition<Type> weighted(boolean roundRobin, String distributionRatio) {
        return weighted(roundRobin, distributionRatio, ",");
    }

    /**
     * Uses weighted load balancer
     *
     * @param roundRobin                   used to set the processor selection algorithm.
     * @param distributionRatio            String of weighted ratios for distribution of messages.
     * @param distributionRatioDelimiter   String containing delimiter to be used for ratios
     * @return the builder
     */
    public LoadBalanceDefinition<Type> weighted(boolean roundRobin, String distributionRatio, String distributionRatioDelimiter) {
        WeightedLoadBalancerDefinition def = new WeightedLoadBalancerDefinition();
        def.setRoundRobin(roundRobin);
        def.setDistributionRatio(distributionRatio);
        def.setDistributionRatioDelimiter(distributionRatioDelimiter);
        setLoadBalancerType(def);
        return this;
    }

    /**
     * Uses round robin load balancer
     *
     * @return the builder
     */
    public LoadBalanceDefinition<Type> roundRobin() {
        setLoadBalancerType(new RoundRobinLoadBalancerDefinition());
        return this;
    }

    /**
     * Uses random load balancer
     *
     * @return the builder
     */
    public LoadBalanceDefinition<Type> random() {
        setLoadBalancerType(new RandomLoadBalancerDefinition());
        return this;
    }

    /**
     * Uses the custom load balancer
     *
     * @param ref reference to lookup a custom load balancer from the {@link org.apache.camel.spi.Registry} to be used.
     * @return the builder
     */
    public LoadBalanceDefinition<Type> custom(String ref) {
        CustomLoadBalancerDefinition balancer = new CustomLoadBalancerDefinition();
        balancer.loadBalancer("#bean:" + ref);
        setLoadBalancerType(balancer);
        return this;
    }

    /**
     * Uses sticky load balancer
     *
     * @param correlationExpression  the expression for correlation
     * @return  the builder
     */
    public LoadBalanceDefinition<Type> sticky(Expression correlationExpression) {
        StickyLoadBalancerDefinition def = new StickyLoadBalancerDefinition();
        def.correlationExpression(new ExpressionDefinition(correlationExpression));
        setLoadBalancerType(def);
        return this;
    }

    /**
     * Uses topic load balancer
     *
     * @return the builder
     */
    public LoadBalanceDefinition<Type> topic() {
        setLoadBalancerType(new TopicLoadBalancerDefinition());
        return this;
    }

#elseif( $data.name == 'aggregate' )
    public AggregationStrategyClause<AggregateDefinition<Type>> strategy() {
        return aggregationStrategy();
    }

    public AggregateDefinition<Type> strategy(AggregationStrategy aggregationStrategy) {
        return aggregationStrategy(aggregationStrategy);
    }

    public AggregateDefinition<Type> strategy(String aggregationStrategy) {
        return aggregationStrategy(aggregationStrategy);
    }

#elseif( $data.name == 'onException' || $data.name == 'onCompletion' )
    private boolean routeScoped;
    public void setRouteScoped(boolean routeScoped) {
        this.routeScoped = routeScoped;
    }
    public boolean isRouteScoped() {
        return routeScoped;
    }
#end
#foreach( $prop in ${data.properties} )
    #if ( ${prop.name} != "outputs" && ${prop.name} != "expression" )
        #set( $propname = ${main.camelCaseUpper(${prop.name})} )
        #set( $propnamelow = ${main.camelCaseLower(${prop.name})} )
        #set( $last = $prop )
        #set( $nbprops = 0 )
        #foreach( $p in ${data.properties} )
            #if( ${p.name} == ${prop.name} )
                #set( $last = $p )
                #set( $nbprops = $nbprops + 1 )
            #end
        #end
        #if( ${prop.type} == 'model:expression' || $prop.type == 'model:predicate' )
            #if( ${prop.type} == 'model:expression' )
                #set( $type = 'Expression' )
            #else
                #set( $type = 'Predicate' )
            #end
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${type}Clause<${name}<${paramst}Type>> ${propnamelow}() {
        ${type}Clause<${name}<${paramst}Type>> clause = new ${type}Clause<>(this);
        ${propnamelow}(clause);
        return clause;
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}(ExpressionDefinition ${propnamelow}) {
        doSetProperty("${prop.name}", ${prop.name});
        return this;
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}(${type} ${propnamelow}) {
        ${propnamelow}(new ExpressionDefinition(${propnamelow}));
        return this;
    }

            #if( $last == $prop )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}(String ${propnamelow}) {
        ${propnamelow}(new ExpressionDefinition(${propnamelow}));
        return this;
    }
            #end

        #elseif( ${prop.type.startsWith('list(model:')} )
            #set( $type = ${main.getType($prop.type)} )
            #set( $stype = ${main.getType(${prop.type.substring(5, ${prop.type.length()} - 1)})} )
            #set( $singular = ${main.singular(${propname})} )
            #set( $singularlow = ${main.camelCaseLower(${singular})} )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}(${type} ${propnamelow}) {
        doSetProperty("${prop.name}", ${prop.name});
        return this;
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> add${singular}(${stype} ${singularlow}) {
        ((${type}) doGetProperty("${propnamelow}", this::newList)).add(${singularlow});
        return this;
    }

        #else
            #if( $prop.type == 'java:org.apache.camel.AggregationStrategy' )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public AggregationStrategyClause<${name}<${paramst}Type>> ${propnamelow}() {
        AggregationStrategyClause<${name}<${paramst}Type>> clause = new AggregationStrategyClause<>(this);
        doSetProperty("${prop.name}", clause);
        return clause;
    }


            #end
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}(${main.getType($prop.type)} ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
        return this;
    }

            #if( $nbprops == 1 && ${prop.type} == 'boolean' )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}() {
        doSetProperty("${prop.name}", true);
        return this;
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
                #if( $propname == 'asyncDelayed' )
                    #set( $nopropname = 'syncDelayed' )
                #else
                    #set( $nopropname = 'no' + ${propname} )
                #end
    public ${name}<${paramst}Type> ${nopropname}() {
        doSetProperty("${prop.name}", false);
        return this;
    }

            #end
            #if( $last == $prop && ${prop.type} != 'string' )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${name}<${paramst}Type> ${propnamelow}(String ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
        return this;
    }

            #end
        #end
    #end
#end
#foreach( $prop in ${data.properties} )
    #if ( ${prop.name} != "outputs" && ${prop.name} != "expression" )
        #set( $propname = ${main.camelCaseUpper(${prop.name})} )
        #set( $propnamelow = ${main.camelCaseLower(${prop.name})} )
        #set( $last = $prop )
        #set( $nbprops = 0 )
        #foreach( $p in ${data.properties} )
            #if( ${p.name} == ${prop.name} )
                #set( $last = $p )
                #set( $nbprops = $nbprops + 1 )
            #end
        #end
        #if( $last == $prop )
            #if( $nbprops == 1 && ${prop.type} == 'model:expression' )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public void set${propname}(ExpressionDefinition ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ExpressionDefinition get${propname}() {
        return (ExpressionDefinition) doGetProperty("${prop.name}");
    }

            #elseif( $nbprops == 1 && ${prop.type} == 'string' )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public void set${propname}(String ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public String get${propname}() {
        return (String) doGetProperty("${prop.name}");
    }

            #elseif( $nbprops == 1 && ${prop.type.startsWith('list(model:')} )
                #set( $type = ${main.getType($prop.type)} )
                #set( $stype = ${main.getType(${prop.type.substring(5, ${prop.type.length()} - 1)})} )
                #set( $singular = ${main.singular(${propname})} )
                #set( $singularlow = ${main.camelCaseLower(${singular})} )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public void set${propname}(${type} ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${type} get${propname}() {
        return (${type}) doGetProperty("${prop.name}");
    }

            #elseif( $nbprops == 1 && ${prop.type.startsWith('model:')} && ${prop.type} != 'model:endpoint' )
                #set( $type = ${main.getType($prop.type)} )
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public void set${propname}(${type} ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public ${type} get${propname}() {
        return (${type}) doGetProperty("${prop.name}");
    }

            #else
    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public void set${propname}(Object ${propnamelow}) {
        doSetProperty("${prop.name}", ${propnamelow});
    }

    ${main.javadoc(${prop.description} + ${newline} + "This property is of type <code>" + ${prop.type} + "</code>.", "    ")}
    public Object get${propname}() {
        return doGetProperty("${prop.name}");
    }

            #end
        #end
    #end
#end

    public Type end() {
        return (Type) super.end();
    }
}